<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、简介​    本节内容主要下列七种方法： ​    1、朴素法：以序列训练集中的最后一个结果作为未来的预测结果； ​    2、简单平均法：以训练集中所有数据的平均值作为未来的预测结果； ​    3、移动平均法：以序列最后一段时间数据的平均值作为未来预测的结果，可以是60天&#x2F;40天等； ​    4、简单指数平滑法：基于指数递降的方式，例如 yt&#x3D;ayt + (1-a)yt-1。基于递">
<meta property="og:type" content="article">
<meta property="og:title" content="时序预测-从朴素法到ARIMA的最优调参">
<meta property="og:url" content="http://yoursite.com/2020/02/27/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B-%E4%BB%8E%E6%9C%B4%E7%B4%A0%E6%B3%95%E5%88%B0ARIMA%E7%9A%84%E6%9C%80%E4%BC%98%E8%B0%83%E5%8F%82/index.html">
<meta property="og:site_name" content="达达的博客">
<meta property="og:description" content="一、简介​    本节内容主要下列七种方法： ​    1、朴素法：以序列训练集中的最后一个结果作为未来的预测结果； ​    2、简单平均法：以训练集中所有数据的平均值作为未来的预测结果； ​    3、移动平均法：以序列最后一段时间数据的平均值作为未来预测的结果，可以是60天&#x2F;40天等； ​    4、简单指数平滑法：基于指数递降的方式，例如 yt&#x3D;ayt + (1-a)yt-1。基于递">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploader.shimo.im/f/k19rHa6Z714nrPdJ.png">
<meta property="og:image" content="https://uploader.shimo.im/f/qAzRYGvWOr8J0YY0.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/zOlyyO0tH6IwxvMQ.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/I3T4n6ZRTkEgbp47.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/FjcVivdy6cglHaoM.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/Tpqt8zyq5XcRBJVz.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/mjg73kKq3Ck5Tl6b.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/xKCZloshqcs8Q2NK.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/fHorhOpKRasH85si.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/82ekwrykf3IRqfDF.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/snCRT1i2ZKIvVtOP.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/LgXVWczpUfM2CcMO.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/75syJiJ2v0oJwVdV.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/eVKlAC3bxNoT18fG.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/9AZy2QZTE3Y0Utew.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/Ap7MlMSjKs4KAevQ.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/CM2UtcQ29MQVnuZZ.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/Mk2TFpJVjdA9Hbje.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/hlozYqJkWEk4aGp8.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/ECJlGdWefaE9b03I.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/nhoELqbBCksZxNQV.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/YWc0AAx9PWsKfwXo.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/l8kJ3SIErw8MbjG8.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/EQrwzQ7rR0U0wyVV.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/ma9OJIClEh42NJ4K.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/tZkBlCbmx5gVsoHx.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/GGuF48vtqpAkvzdM.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/RlTnBQwej1MPE23d.png!thumbnail">
<meta property="og:image" content="https://uploader.shimo.im/f/bbJ0befq5RgQ07JH.png!thumbnail">
<meta property="article:published_time" content="2020-02-26T21:44:39.000Z">
<meta property="article:modified_time" content="2020-02-27T09:56:19.827Z">
<meta property="article:author" content="骆旺达">
<meta property="article:tag" content="时序预测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploader.shimo.im/f/k19rHa6Z714nrPdJ.png">

<link rel="canonical" href="http://yoursite.com/2020/02/27/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B-%E4%BB%8E%E6%9C%B4%E7%B4%A0%E6%B3%95%E5%88%B0ARIMA%E7%9A%84%E6%9C%80%E4%BC%98%E8%B0%83%E5%8F%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>时序预测-从朴素法到ARIMA的最优调参 | 达达的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">达达的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录历程</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B-%E4%BB%8E%E6%9C%B4%E7%B4%A0%E6%B3%95%E5%88%B0ARIMA%E7%9A%84%E6%9C%80%E4%BC%98%E8%B0%83%E5%8F%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cdn.dadastudio.top/cdn-1253701280/typora20191119212932.png">
      <meta itemprop="name" content="骆旺达">
      <meta itemprop="description" content="你不会找到路，除非你敢于迷路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="达达的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          时序预测-从朴素法到ARIMA的最优调参
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-27 05:44:39 / 修改时间：17:56:19" itemprop="dateCreated datePublished" datetime="2020-02-27T05:44:39+08:00">2020-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">时序预测</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer" />


<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​    本节内容主要下列七种方法：</p>
<p>​    1、朴素法：以序列训练集中的最后一个结果作为未来的预测结果；</p>
<p>​    2、简单平均法：以训练集中所有数据的平均值作为未来的预测结果；</p>
<p>​    3、移动平均法：以序列最后一段时间数据的平均值作为未来预测的结果，可以是60天/40天等；</p>
<p>​    4、简单指数平滑法：基于指数递降的方式，例如 yt=ayt + (1-a)yt-1。基于递降训练集的权值，获得整个训练集信息，预测未来趋势。</p>
<p>​    5、霍尔特线性趋势发：在简单指数平滑的基础上加了，趋势方程，即预测有一个向上/向下的趋势。</p>
<p>​    6、HOLT-winters季节性预测法：基于周期性预测时间序列，适用于具有一定周期的序列。学习周期序列运行规律。</p>
<p>​    7、ARIMA（ar:自回归模型，I：差分，MA移动平均模型），三个模型基于历史规律进行趋势预测。</p>
<h3 id="二、时间序列预测概述"><a href="#二、时间序列预测概述" class="headerlink" title="二、时间序列预测概述"></a>二、时间序列预测概述</h3><h4 id="2-1-如何预测未来几日JetRail高铁的乘客数量"><a href="#2-1-如何预测未来几日JetRail高铁的乘客数量" class="headerlink" title="2.1 如何预测未来几日JetRail高铁的乘客数量"></a>2.1 如何预测未来几日JetRail高铁的乘客数量</h4><h5 id="2-1-1-问题描述"><a href="#2-1-1-问题描述" class="headerlink" title="2.1.1 问题描述"></a>2.1.1 问题描述</h5><p>​    问题描述：Braniff Jetrail Fastpark系统是一种悬挂式单轨系统，于1970年4月18日至1974年1月13日在美国得克萨斯州达拉斯的Dallas Love Field运行，由伊利诺伊州芝加哥的Stanray公司制造，将乘客及其行李从偏远的停车场运送到机场航站楼。</p>
<h5 id="2-1-2-数据读取"><a href="#2-1-2-数据读取" class="headerlink" title="2.1.2 数据读取"></a>2.1.2 数据读取</h5><p>​    导入pandas，numpy及matplotlib库，进行数据处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>
<p>​    读取数据，并显示前五个数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;.&#x2F;data&#x2F;JetRail&#x2F;Train.csv&#39;,nrows&#x3D;11856)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/k19rHa6Z714nrPdJ.png" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">将数据集拆分成训练集和测试集，并对数据进行预处理，最后进行数据集可视化。</span><br><span class="line">train &#x3D; df[0:10392]</span><br><span class="line">test &#x3D; df[10392:]</span><br><span class="line"> </span><br><span class="line"># 将时间数据进行转换，例如将25-08-2018 00:00转换成2012-08-25 00:00。</span><br><span class="line">df[&#39;Timestamp&#39;] &#x3D; pd.to_datetime(df[&#39;Datetime&#39;], format&#x3D;&#39;%d-%m-%Y %H:%M&#39;)</span><br><span class="line"># 用时间例如2012-08-25 00:00 替换当前的index</span><br><span class="line">df.index &#x3D; df[&#39;Timestamp&#39;]</span><br><span class="line"></span><br><span class="line"># 以天为单位（&#39;D&#39;）, 对数据进行重采样，并取均值。</span><br><span class="line">df &#x3D; df.resample(&#39;D&#39;).mean()</span><br><span class="line"> </span><br><span class="line"># 同理对训练集进行如上相同操作；</span><br><span class="line">train[&#39;Timestamp&#39;] &#x3D; pd.to_datetime(train[&#39;Datetime&#39;], format&#x3D;&#39;%d-%m-%Y %H:%M&#39;)</span><br><span class="line">train.index &#x3D; train[&#39;Timestamp&#39;]</span><br><span class="line">train &#x3D; train.resample(&#39;D&#39;).mean()</span><br><span class="line"> </span><br><span class="line"># 同理对测试集进行如上相同操作</span><br><span class="line">test[&#39;Timestamp&#39;] &#x3D; pd.to_datetime(test[&#39;Datetime&#39;], format&#x3D;&#39;%d-%m-%Y %H:%M&#39;)</span><br><span class="line">test.index &#x3D; test[&#39;Timestamp&#39;]</span><br><span class="line">test &#x3D; test.resample(&#39;D&#39;).mean()</span><br><span class="line">########################################################</span><br><span class="line"># 数据可视化</span><br><span class="line"># Plotting data</span><br><span class="line">train.Count.plot(figsize&#x3D;(15,8), title&#x3D; &#39;Daily Ridership&#39;, fontsize&#x3D;14)</span><br><span class="line">test.Count.plot(figsize&#x3D;(15,8), title&#x3D; &#39;Daily Ridership&#39;, fontsize&#x3D;14)</span><br><span class="line">########################################################</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>​    我们可以看到在年份上，训练集和测试集的趋势折线图。<br>​    蓝色为训练集，黄色为测试集。</p>
<p><img src="https://uploader.shimo.im/f/qAzRYGvWOr8J0YY0.png!thumbnail" alt="图片"></p>
<h5 id="2-1-3-朴素法"><a href="#2-1-3-朴素法" class="headerlink" title="2.1.3 朴素法"></a>2.1.3 朴素法</h5><p>​    理论介绍：如果数据集在一段时间内都很稳定，我们想预测第二天的价格，可以取前面一天的价格，预测第二天的值。这种假设第一个预测点和上一个观察点相等的预测方法就叫朴素法。</p>
<p>​    算法：</p>
<p>​    1、获得训练集dd,并将训练集最后一个元素dd[len(dd)-1]赋值给y_hat；</p>
<p>​    2、可视化查看预测结果。<strong>发现朴素法预测的结果为一条直线。</strong></p>
<p>​    3、进行mse检验，查看误差。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dd &#x3D; np.asarray(train[&#39;Count&#39;])</span><br><span class="line">y_hat &#x3D; test.copy()</span><br><span class="line">########################################################</span><br><span class="line">y_hat[&#39;naive&#39;] &#x3D; dd[len(dd)-1]</span><br><span class="line">########################################################</span><br><span class="line">plt.figure(figsize&#x3D;(12, 8))</span><br><span class="line"></span><br><span class="line">plt.plot(train.index, train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test.index, test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat.index, y_hat[&#39;naive&#39;], label&#x3D;&#39;Naive Forecast&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.title(&quot;Naive Forecast&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/zOlyyO0tH6IwxvMQ.png!thumbnail" alt="图片"></p>
<p>​    3、误差检验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 导入度量指标库</span><br><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line">########################################################</span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(y_hat[&#39;naive&#39;],test[&#39;Count&#39;]))</span><br><span class="line">########################################################</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>输出：43.91640614391676</p>
<h5 id="2-1-3-简单平均法"><a href="#2-1-3-简单平均法" class="headerlink" title="2.1.3 简单平均法"></a>2.1.3 简单平均法</h5><p>​    理论：物品价格会随机上涨和下跌，平均价格会保持一致。我们经常会遇到一些数据集，虽然在一定时期内出现小幅变动，但每个时间段的平均值确实保持不变。这种情况下，我们可以预测出第二天的价格大致和过去天数的价格平均值一致。这种将预期值等同于之前所有观测点的平均值的预测方法就叫简单平均法。</p>
<p>​    算法：</p>
<p>​    1、获得训练集所有天数Count的平均值：train[‘Count’].mean()</p>
<p>​    2、将平均值赋值给预测list.</p>
<p>​    3、可视化图表。可以发现处于右下角的绿色直线，即为预测曲线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line">y_hat_avg[&#39;avg_forecast&#39;] &#x3D; train[&#39;Count&#39;].mean()</span><br><span class="line">plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;avg_forecast&#39;], label&#x3D;&#39;Average Forecast&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/I3T4n6ZRTkEgbp47.png!thumbnail" alt="图片"></p>
<p>​    4、查看rmse评价指标</p>
<pre><code>可以得出109，与朴素法43相比，预测结果更差。如图所示，确实偏离预测曲线。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;], y_hat_avg[&#39;avg_forecast&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>​    输出：109.88526527082863</p>
<h5 id="2-1-4-移动平均法"><a href="#2-1-4-移动平均法" class="headerlink" title="2.1.4 移动平均法"></a>2.1.4 移动平均法</h5><p>​    理论：物品价格在一段时间内大幅上涨，但后来又趋于平稳。我们也经常会遇到这种数据集，比如价格或销售额某段时间大幅上升或下降。如果我们这时用之前的简单平均法，就得使用所有先前数据的平均值，但在这里使用之前的所有数据是说不通的，因为用开始阶段的价格值会大幅影响接下来日期的预测值。因此，<strong>我们只取最近几个时期的价格平均值</strong>。<strong>很明显这里的逻辑是只有最近的值最要紧。这种用某些窗口来计算平均值的预测方法就叫移动平均法。</strong></p>
<p>​    计算移动平均值涉及到一个有时被称为“滑动窗口”的大小值<strong>p</strong>。使用简单的移动平均模型，我们可以根据之前数值的固定有限数p的平均值预测某个时序中的下一个值。</p>
<p>​    算法：</p>
<p>​    1、获得训练集后60个数据。rolling设置size=60的窗口，mean()求均值。iloc[-1]从最后一个往前数60个数字。</p>
<p>​    2、将获得的均值赋值给预测list.</p>
<p>​    3、可视化预测曲线。如下图绿色曲线所示。相比于朴素法预测的曲线，稍微有些向下偏移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line">########################################################</span><br><span class="line">y_hat_avg[&#39;moving_avg_forecast&#39;] &#x3D; train[&#39;Count&#39;].rolling(60).mean().iloc[-1]</span><br><span class="line">########################################################</span><br><span class="line">plt.figure(figsize&#x3D;(16,8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;moving_avg_forecast&#39;], label&#x3D;&#39;Moving Average Forecast&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/FjcVivdy6cglHaoM.png!thumbnail" alt="图片"></p>
<p>​    4、计算mse指标</p>
<p>​    输入rmse值为46.72.仍比朴素法预测值43.95稍差。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line"> </span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;],y_hat_avg[&#39;moving_avg_forecast&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>输入：46.72840725106963</p>
<p>​    总结：我们可以看到，对于这个数据集，<strong>朴素法比简单平均法和移动平均法的表现要好</strong>。此外，我们还可以<strong>试试简单指数平滑法</strong>，它比移动平均法的一个进步之处就是相<strong>当于对移动平均法进行了加权</strong>。在上文移动平均法可以看到，我们对<strong>“p”中的观察值赋予了同样的权重</strong>。但是我们可能遇到一些情况，<strong>比如“p”中每个观察值会以不同的方式影响预测结果</strong>。<strong>将过去观察值赋予不同权重的方法就叫做加权移动平均法</strong>。加权移动平均法其实还是一种移动平均法，<strong>只是“滑动窗口期”内的值被赋予不同的权重</strong>，通常来讲，<strong>最近时间点的值发挥的作用更大</strong>了。</p>
<h5 id="2-1-5-简单指数平滑法"><a href="#2-1-5-简单指数平滑法" class="headerlink" title="2.1.5 简单指数平滑法"></a>2.1.5 简单指数平滑法</h5><p>​    理论：我们注意到简单平均法和加权移动平均法在选取时间点的思路上存在较大的差异。我们就需要在这两种方法之间取一个折中的方法，在<strong>将所有数据考虑在内的同时也能给数据赋予不同非权重</strong>。例如，<strong>相比更早时期内的观测值，它会给近期的观测值赋予更大的权重</strong>。按照这种原则工作的方法就叫做<strong>简单指数平滑法</strong>。它通过加权平均值计算出预测值，其中权重随着观测值从早期到晚期的变化呈指数级下降，<strong>最小的权重和最早的观测值相关</strong>： </p>
<p>​    如下公式所示：</p>
<p><img src="https://uploader.shimo.im/f/Tpqt8zyq5XcRBJVz.png!thumbnail" alt="图片"></p>
<p>​     即：<img src="https://uploader.shimo.im/f/mjg73kKq3Ck5Tl6b.png!thumbnail" alt="图片">，其中，a为平滑系数。</p>
<p>​    其中0≤α≤1是平滑参数。对时间点T+1的单步预测值是时序y1,…,yT的所有观测值的加权平均数。权重下降的速率由参数α控制。</p>
<p>​    算法：</p>
<p>​    1、引入简单指数平滑库。</p>
<p>​    2、建立模型fit,利用SimpleExpSmoothing训练训练集，设置平滑指数为0.6.</p>
<p>​    3、利用模型预测长度为len(test)的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from statsmodels.tsa.api import SimpleExpSmoothing</span><br><span class="line"> </span><br><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line">fit &#x3D; SimpleExpSmoothing(np.asarray(train[&#39;Count&#39;])).fit(smoothing_level&#x3D;0.6, optimized&#x3D;False)</span><br><span class="line">y_hat_avg[&#39;SES&#39;] &#x3D; fit.forecast(len(test))</span><br><span class="line">plt.figure(figsize&#x3D;(16, 8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;SES&#39;], label&#x3D;&#39;SES&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/xKCZloshqcs8Q2NK.png!thumbnail" alt="图片"></p>
<p>​    4、计算rmse指标</p>
<p>​    rmse=43.357效果稍微胜过朴素法43.9</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line"> </span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;], y_hat_avg[&#39;SES&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>​    输出：43.357625225228155</p>
<h5 id="2-1-6-霍尔特（Holt-线性趋势法"><a href="#2-1-6-霍尔特（Holt-线性趋势法" class="headerlink" title="2.1.6 霍尔特（Holt)线性趋势法"></a>2.1.6 霍尔特（Holt)线性趋势法</h5><p><img src="https://uploader.shimo.im/f/fHorhOpKRasH85si.png!thumbnail" alt="图片"></p>
<p>​    如果物品的价格是不断上涨的（见上图），我们上面的方法并没有考虑这种趋势，即我们在一段时间内观察到的价格的总体模式。在上图例子中，我们可以看到物品的价格呈上涨趋势。虽然上面这些方法都可以应用于这种趋势，但我们仍需要一种方法可以在无需假设的情况下，准确预测出价格趋势。这种考虑到数据集变化趋势的方法就叫做霍尔特线性趋势法。</p>
<p>​    每个时序数据集可以分解为相应的几个部分：趋势（Trend），季节性(Seasonal)和残差(Residual)。任何呈现某种趋势的数据集都可以用霍尔特线性趋势法用于预测。</p>
<p>​    算法：</p>
<p>​    1、获得训练数据的各项指标。例如，趋势，季节性（周期），残差</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import statsmodels.api as sm</span><br><span class="line"> </span><br><span class="line">sm.tsa.seasonal_decompose(train[&#39;Count&#39;]).plot()</span><br><span class="line">result &#x3D; sm.tsa.stattools.adfuller(train[&#39;Count&#39;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/82ekwrykf3IRqfDF.png!thumbnail" alt="图片"></p>
<p>​    我们从图中可以看出，该数据集呈上升趋势。因此我们可以用霍尔特线性趋势法预测未来价格。该算法包含三个方程：一个水平方程，一个趋势方程，一个方程将二者相加以得到预测值：<img src="https://uploader.shimo.im/f/snCRT1i2ZKIvVtOP.png!thumbnail" alt="图片"></p>
<p>​    基于上述三个方程，我们建立霍尔特线性趋势模型</p>
<p>​    1、引入Holt包；</p>
<p>​    2、建立模型fit,并设置平滑指数为0.3，平滑斜率为0.1；</p>
<p>​    3、预测长度为len(test)的数据。</p>
<p>​    4、可视化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from statsmodels.tsa.api import Holt</span><br><span class="line"> </span><br><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line"> </span><br><span class="line">fit &#x3D; Holt(np.asarray(train[&#39;Count&#39;])).fit(smoothing_level&#x3D;0.3, smoothing_slope&#x3D;0.1)</span><br><span class="line">y_hat_avg[&#39;Holt_linear&#39;] &#x3D; fit.forecast(len(test))</span><br><span class="line"> </span><br><span class="line">plt.figure(figsize&#x3D;(16, 8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;Holt_linear&#39;], label&#x3D;&#39;Holt_linear&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/LgXVWczpUfM2CcMO.png!thumbnail" alt="图片"></p>
<p>​    可以看到图像有个上升的趋势。</p>
<p>​    5、计算rmse指标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line"> </span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;], y_hat_avg[&#39;Holt_linear&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>​    输出：43.056259611507286</p>
<h5 id="2-1-7-Holt-Winters季节性预测模型"><a href="#2-1-7-Holt-Winters季节性预测模型" class="headerlink" title="2.1.7 Holt-Winters季节性预测模型"></a>2.1.7 Holt-Winters季节性预测模型</h5><p>​    理论：在应用这种算法前，我们先介绍一个新术语。假如有家酒店坐落在半山腰上，夏季的时候生意很好，顾客很多，但每年其余时间顾客很少。因此，每年夏季的收入会远高于其它季节，而且每年都是这样，那么这种重复现象叫做“季节性”（Seasonality）。如果数据集在一定时间段内的固定区间内呈现相似的模式，那么该数据集就具有季节性。</p>
<p>​    季节性示例图如下：（旺季和淡季交叉出现）</p>
<p><img src="https://uploader.shimo.im/f/75syJiJ2v0oJwVdV.png!thumbnail" alt="图片"></p>
<p>​    我们之前讨论的5种模型在预测时并没有考虑到数据集的季节性，因此我们需要一种能考虑这种因素的方法。应用到这种情况下的算法就叫做Holt-Winters季节性预测模型，它是一种<strong>三次指数平滑预测</strong>，其背后的理念就是除了<strong>水平</strong>和<strong>趋势</strong>外，还将<strong>指数平滑应用到季节分量上</strong>。</p>
<p>​    Holt-Winters季节性预测模型由预测函数和三次平滑函数——一个是水平函数ℓt，一个是趋势函数bt，一个是季节分量 st，以及平滑参数α,β和γ。</p>
<p><img src="https://uploader.shimo.im/f/eVKlAC3bxNoT18fG.png!thumbnail" alt="图片"></p>
<p>​    其中 s 为季节循环的长度。平滑参数均在[0,1]区间内。水平函数为季节性调整的观测值和时间点t处非季节预测之间的加权平均值。趋势函数和霍尔特线性方法中的含义相同。季节函数为当前季节指数和去年同一季节的季节性指数之间的加权平均值。在本算法，我们同样可以用相加和相乘的方法。<strong>当季节性变化大致相同时，优先选择相加方法</strong>，<strong>而当季节变化的幅度与各时间段的水平成正比时，优先选择相乘的方法</strong>。</p>
<p>​    算法：</p>
<p>​    1、引入指数平滑库</p>
<p>​    2、建立模型fit1,并输入训练数据。设置季节周期为7，趋势为加，季节为加。（即变化幅度大致相同）</p>
<p>​    3、可视化结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from statsmodels.tsa.api import ExponentialSmoothing</span><br><span class="line"> </span><br><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line">fit1 &#x3D; ExponentialSmoothing(np.asarray(train[&#39;Count&#39;]), seasonal_periods&#x3D;7, trend&#x3D;&#39;add&#39;, seasonal&#x3D;&#39;add&#39;, ).fit()</span><br><span class="line">y_hat_avg[&#39;Holt_Winter&#39;] &#x3D; fit1.forecast(len(test))</span><br><span class="line">plt.figure(figsize&#x3D;(16, 8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;Holt_Winter&#39;], label&#x3D;&#39;Holt_Winter&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/9AZy2QZTE3Y0Utew.png!thumbnail" alt="图片"></p>
<p>​    如图所示，明显有一点与真实值相近似。</p>
<p>​    4、计算rmse指标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line"> </span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;], y_hat_avg[&#39;Holt_Winter&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>​    输出：23.961492566159794</p>
<h5 id="2-1-8-自回归移动平均模型（ARIMA）"><a href="#2-1-8-自回归移动平均模型（ARIMA）" class="headerlink" title="2.1.8 自回归移动平均模型（ARIMA）"></a>2.1.8 自回归移动平均模型（ARIMA）</h5><p>​    理论：另一个场景的时序模型是自回归移动平均模型（ARIMA）。指数平滑模型都是基于数据中的<strong>趋势和季节性</strong>的描述，而<strong>自回归移动平均模型的目标是描述数据中彼此之间的关系</strong>。ARIMA的一个优化版就是季节性ARIMA。它像Holt-Winters季节性预测模型一样，也把数据集的季节性考虑在内。</p>
<p>​    AR：auto regression</p>
<p>​    MA:move average</p>
<p>​    I: Diff差分</p>
<p>​    算法：</p>
<p>​    1、映入统计模型api</p>
<p>​    2、建立模型fit1,并调用SARIMAX季节性自回归移动平均模型。设置参数。</p>
<p>​    参数如下：(参数挑选非常重要）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#order 自回归，差分，滑动平均项 (p,d,q)</span><br><span class="line">#seasonal_order  季节因素的自回归，差分，移动平均，周期 (P,D,Q,s)</span><br></pre></td></tr></table></figure>
<p>​    3、可视化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import statsmodels.api as sm</span><br><span class="line"> </span><br><span class="line">y_hat_avg &#x3D; test.copy()</span><br><span class="line">#order 自回归，差分，滑动平均项 (p,d,q)</span><br><span class="line">#seasonal_order  季节因素的自回归，差分，移动平均，周期 (P,D,Q,s)</span><br><span class="line">fit1 &#x3D; sm.tsa.statespace.SARIMAX(train.Count, order&#x3D;(2, 1, 4), seasonal_order&#x3D;(0, 1, 1, 7)).fit()</span><br><span class="line">y_hat_avg[&#39;SARIMA&#39;] &#x3D; fit1.predict(start&#x3D;&quot;2013-11-1&quot;, end&#x3D;&quot;2013-12-31&quot;, dynamic&#x3D;True)</span><br><span class="line">plt.figure(figsize&#x3D;(16, 8))</span><br><span class="line">plt.plot(train[&#39;Count&#39;], label&#x3D;&#39;Train&#39;)</span><br><span class="line">plt.plot(test[&#39;Count&#39;], label&#x3D;&#39;Test&#39;)</span><br><span class="line">plt.plot(y_hat_avg[&#39;SARIMA&#39;], label&#x3D;&#39;SARIMA&#39;)</span><br><span class="line">plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/Ap7MlMSjKs4KAevQ.png!thumbnail" alt="图片"></p>
<p>​    4、计算rmse指标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line">from math import sqrt</span><br><span class="line"> </span><br><span class="line">rms &#x3D; sqrt(mean_squared_error(test[&#39;Count&#39;], y_hat_avg[&#39;SARIMA&#39;]))</span><br><span class="line">print(rms)</span><br></pre></td></tr></table></figure>
<p>​    输出：26.04168407306019</p>
<h4 id="3-2、ARIMA模型参数详解"><a href="#3-2、ARIMA模型参数详解" class="headerlink" title="3.2、ARIMA模型参数详解"></a>3.2、ARIMA模型参数详解</h4><h5 id="3-2-1-数据引入"><a href="#3-2-1-数据引入" class="headerlink" title="3.2.1 数据引入"></a>3.2.1 数据引入</h5><p>​    1、引入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import statsmodels.api as sm</span><br><span class="line">data &#x3D; pd.read_csv(&quot;arima-demo.csv&quot;,parse_dates&#x3D;[&#39;date&#39;],index_col&#x3D;&#39;date&#39;)</span><br><span class="line">print(data.head())</span><br><span class="line">data.plot(figsize&#x3D;(12,6))</span><br></pre></td></tr></table></figure>
<p>​    数据为，[‘date’,’ct’]两个属性的list</p>
<p><img src="https://uploader.shimo.im/f/CM2UtcQ29MQVnuZZ.png!thumbnail" alt="图片"></p>
<p>​     图像如下所示：</p>
<p><img src="https://uploader.shimo.im/f/Mk2TFpJVjdA9Hbje.png!thumbnail" alt="图片"></p>
<h5 id="3-2-2-差分运算"><a href="#3-2-2-差分运算" class="headerlink" title="3.2.2 差分运算"></a>3.2.2 差分运算</h5><p>​    ARIMA 模型对时间序列的要求是平稳性。</p>
<p>​    1、平稳性就是要求经由样本时间序列所得到的拟合曲线，在未来的一段时间内仍能顺着现有的形态“惯性”地延续下去。</p>
<p>​    2、而平稳性要求序列的均值和方差不发生明显的变化。</p>
<p>​    因此，当你得到一个非平稳的时间序列时，首先要做的即是做时间序列的差分，直到得到一个平稳时间序列。如果<strong>你对时间序列做d次差分才能得到一个平稳序列</strong>，那么可以使用ARIMA(p,d,q)模型，其中<strong>d是差分次数</strong>。</p>
<p>​    下为一阶差分的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iff1 &#x3D; data.diff(1)</span><br><span class="line">diff1.plot(figsize&#x3D;(12,6))</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/hlozYqJkWEk4aGp8.png!thumbnail" alt="图片"></p>
<p>​    一阶差分的时间序列的均值和方差已经基本平稳，不过我们还是可以比较一下二阶差分的效果。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iff2 &#x3D; data.diff(2)</span><br><span class="line">diff2.plot(figsize&#x3D;(12,6))</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/ECJlGdWefaE9b03I.png!thumbnail" alt="图片"></p>
<h5 id="3-2-3-ARIMA基础参数介绍"><a href="#3-2-3-ARIMA基础参数介绍" class="headerlink" title="3.2.3 ARIMA基础参数介绍"></a>3.2.3 ARIMA基础参数介绍</h5><p>​    时间序列预测中最常用的方法之一就是被称为ARIMA模型，它代表了Auto regRessive综合Moving Average版本 。 ARIMA是可以适应时间序列数据的模型，以便更好地了解或预测系列中的未来点。</p>
<p>​    ARIMA模型有三个不同的整数（ p ， d ， q ）用于参数化ARIMA模型。 因此，ARIMA模型用符号ARIMA(p, d, q) 。 这三个参数共计数据集中的季节性，趋势和噪音：</p>
<p>​    p是模型的自回归部分。 它允许我们将过去价值观的影响纳入我们的模型。 直观地说，这将是类似的，<strong>表示如果过去3天已经变暖，明天可能会变暖</strong>。</p>
<p>​    d是模型的集成部分。 这包括模型中包含差异量（即从当前值减去的过去时间点的数量）以适用于时间序列的术语。 直观地说，<strong>这将类似于说如果过去三天的温度差异非常小，明天可能会有相同的温度</strong>。</p>
<p>​    q是模型的移动平均部分。 这允许我们将模型的误差设置为过去以前时间点观察到的误差值的线性组合。</p>
<p>​    如下图代码所示，要确定参数，我们先得获得acf图和pacf图：</p>
<p>​    其中，<strong>ACF：自相关图</strong>和<strong>PACF：偏相关图</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diff1.dropna(inplace&#x3D;True)</span><br><span class="line">fig &#x3D; plt.figure(figsize&#x3D;(12,8))</span><br><span class="line">ax1&#x3D;fig.add_subplot(211)</span><br><span class="line">fig &#x3D; sm.graphics.tsa.plot_acf(diff1,lags&#x3D;40,ax&#x3D;ax1)</span><br><span class="line">ax2 &#x3D; fig.add_subplot(212)</span><br><span class="line">fig &#x3D; sm.graphics.tsa.plot_pacf(diff1,lags&#x3D;40,ax&#x3D;ax2)</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/nhoELqbBCksZxNQV.png!thumbnail" alt="图片"></p>
<p>​     其中lags 表示滞后的阶数，以上分别得到acf 图和pacf 图。通过两图观察得到：</p>
<p>​    自相关图显示滞后有3（4）个阶超出了置信边界</p>
<p>​    偏相关图显示在滞后1至7阶（lags 1,2,…，7）时的偏自相关系数超出了置信边界，从lag 7之后偏自相关系数值缩小至0</p>
<p>​    则有以下模型可以供选择：</p>
<p>​    ARMA(0,1)模型：即自相关图在滞后1阶之后缩小为0，且偏自相关缩小至0，则是一个阶数q=1的移动平均模型；</p>
<p>​    ARMA(7,0)模型：即偏自相关图在滞后7阶之后缩小为0，且自相关缩小至0，则是一个阶层p=7的自回归模型；</p>
<p>​    ARMA(7,1)模型：即使得自相关和偏自相关都缩小至零。则是一个混合模型。</p>
<p><img src="https://uploader.shimo.im/f/YWc0AAx9PWsKfwXo.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/l8kJ3SIErw8MbjG8.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/EQrwzQ7rR0U0wyVV.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/ma9OJIClEh42NJ4K.png!thumbnail" alt="图片"></p>
<p><img src="https://uploader.shimo.im/f/tZkBlCbmx5gVsoHx.png!thumbnail" alt="图片"></p>
<h5 id="3-2-4-参数选择"><a href="#3-2-4-参数选择" class="headerlink" title="3.2.4 参数选择"></a>3.2.4 参数选择</h5><p>​    为了确定哪个模型最合适，可以采用如下准则进行判定：</p>
<p>​    AIC=-2 ln(L) + 2 k 中文名字：赤池信息量 akaike information criterion</p>
<p>​    BIC=-2 ln(L) + ln(n)*k  中文名字：贝叶斯信息量 bayesian information criterion</p>
<p>​    HQ=-2 ln(L) + ln(ln(n))*k hannan-quinn criterion</p>
<p>​    实现函数如下：</p>
<p>​    1、设置参数取值区域，并构建result_BIC(贝叶斯信息量）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line"># 设置一个参数取值区域</span><br><span class="line">p_min &#x3D; 0</span><br><span class="line">d_min &#x3D; 1</span><br><span class="line">q_min &#x3D; 0</span><br><span class="line">p_max &#x3D; 8</span><br><span class="line">d_max &#x3D; 1</span><br><span class="line">q_max &#x3D; 5</span><br><span class="line"># Initialize a DataFrame to store the results</span><br><span class="line">results_bic &#x3D; pd.DataFrame(index&#x3D;[&#39;AR&#123;&#125;&#39;.format(i) for i in range(p_min,p_max+1)],</span><br><span class="line">                           columns&#x3D;[&#39;MA&#123;&#125;&#39;.format(i) for i in range(q_min,q_max+1)])</span><br><span class="line">for p,d,q in itertools.product(range(p_min,p_max+1),</span><br><span class="line">                               range(d_min,d_max+1),</span><br><span class="line">                               range(q_min,q_max+1)):</span><br><span class="line">    if p&#x3D;&#x3D;0 and d&#x3D;&#x3D;0 and q&#x3D;&#x3D;0:</span><br><span class="line">        results_bic.loc[&#39;AR&#123;&#125;&#39;.format(p), &#39;MA&#123;&#125;&#39;.format(q)] &#x3D; np.nan</span><br><span class="line">        continue</span><br><span class="line">    try:</span><br><span class="line">        model &#x3D; sm.tsa.SARIMAX(data, order&#x3D;(p, d, q),</span><br><span class="line">                               #enforce_stationarity&#x3D;False,</span><br><span class="line">                               #enforce_invertibility&#x3D;False,</span><br><span class="line">                              )</span><br><span class="line">        results &#x3D; model.fit()</span><br><span class="line">        results_bic.loc[&#39;AR&#123;&#125;&#39;.format(p), &#39;MA&#123;&#125;&#39;.format(q)] &#x3D; results.bic</span><br><span class="line">    except:</span><br><span class="line">        continue</span><br><span class="line">results_bic &#x3D; results_bic[results_bic.columns].astype(float)</span><br></pre></td></tr></table></figure>
<p>​    2、基于BIC准则，画出热力图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">fig, ax &#x3D; plt.subplots(figsize&#x3D;(10, 8))</span><br><span class="line">ax &#x3D; sns.heatmap(results_bic,</span><br><span class="line">                 mask&#x3D;results_bic.isnull(),</span><br><span class="line">                 ax&#x3D;ax,</span><br><span class="line">                 annot&#x3D;True,</span><br><span class="line">                 fmt&#x3D;&#39;.2f&#39;,</span><br><span class="line">                 );</span><br><span class="line">ax.set_title(&#39;BIC&#39;);</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/GGuF48vtqpAkvzdM.png!thumbnail" alt="图片"></p>
<p>​    3、设置参数，进行模型残差检验</p>
<p>​    MA确定为5，AR为6，即p为6，q=5，差分d为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arima815 &#x3D; sm.tsa.SARIMAX(data, order&#x3D;(6,1,5))</span><br><span class="line">model_results &#x3D; arima815.fit()</span><br><span class="line">#残差分析 正态分布 QQ图线性</span><br><span class="line">model_results.plot_diagnostics(figsize&#x3D;(16, 12));</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/RlTnBQwej1MPE23d.png!thumbnail" alt="图片"></p>
<p>​    可视化预测值：预测2017-06-01到2019-06-01的销量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predict_sunspots &#x3D; model_results.predict(&#39;2017-06-01&#39;, &#39;2019-06-01&#39;, dynamic&#x3D;True)</span><br><span class="line">fig, ax &#x3D; plt.subplots(figsize&#x3D;(12, 8))</span><br><span class="line">data.plot(ax&#x3D;ax)</span><br><span class="line">predict_sunspots.plot(ax&#x3D;ax)</span><br></pre></td></tr></table></figure>
<p><img src="https://uploader.shimo.im/f/bbJ0befq5RgQ07JH.png!thumbnail" alt="图片"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<p><a href="https://discussion.datafountain.cn/questions/2322?new=7" target="_blank" rel="noopener">1、DF第一期算法公益直播课【时序预测从朴素法到ARIMA的最优调参方法】</a></p>
<p>2、数据集+录播地址 链接:<a href="https://pan.baidu.com/s/1-_OXiahYPdyUwaU_TXAOLw" target="_blank" rel="noopener">https://pan.baidu.com/s/1-_OXiahYPdyUwaU_TXAOLw</a> 密码:rx5s</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B/" rel="tag"># 时序预测</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/26/Python%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="prev" title="Python小技巧">
      <i class="fa fa-chevron-left"></i> Python小技巧
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、简介"><span class="nav-number">1.</span> <span class="nav-text">一、简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、时间序列预测概述"><span class="nav-number">2.</span> <span class="nav-text">二、时间序列预测概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-如何预测未来几日JetRail高铁的乘客数量"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 如何预测未来几日JetRail高铁的乘客数量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-问题描述"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 问题描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-数据读取"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 数据读取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-朴素法"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 朴素法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-简单平均法"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.3 简单平均法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-4-移动平均法"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.1.4 移动平均法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-5-简单指数平滑法"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.1.5 简单指数平滑法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-6-霍尔特（Holt-线性趋势法"><span class="nav-number">2.1.7.</span> <span class="nav-text">2.1.6 霍尔特（Holt)线性趋势法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-7-Holt-Winters季节性预测模型"><span class="nav-number">2.1.8.</span> <span class="nav-text">2.1.7 Holt-Winters季节性预测模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-8-自回归移动平均模型（ARIMA）"><span class="nav-number">2.1.9.</span> <span class="nav-text">2.1.8 自回归移动平均模型（ARIMA）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2、ARIMA模型参数详解"><span class="nav-number">2.2.</span> <span class="nav-text">3.2、ARIMA模型参数详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-数据引入"><span class="nav-number">2.2.1.</span> <span class="nav-text">3.2.1 数据引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-差分运算"><span class="nav-number">2.2.2.</span> <span class="nav-text">3.2.2 差分运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-ARIMA基础参数介绍"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.2.3 ARIMA基础参数介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-4-参数选择"><span class="nav-number">2.2.4.</span> <span class="nav-text">3.2.4 参数选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="骆旺达"
      src="http://cdn.dadastudio.top/cdn-1253701280/typora20191119212932.png">
  <p class="site-author-name" itemprop="name">骆旺达</p>
  <div class="site-description" itemprop="description">你不会找到路，除非你敢于迷路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">骆旺达</span>
</div>


  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
  <span class="post-meta-divider">|</span>
  <span class="post-meta-divider">|</span>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>
<div class="theme-info">
  <span class="post-meta-divider">|</span>
  <div class="powered-by"></div>
  <span class="post-count">博客全站共6.3k字</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

</body>
</html>
